#!/usr/bin/python
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Author:  Jonas Bernoulli <jonas@bernoul.li>
# Created: 20090909
# Updated: 20100429
# Version: 006 (this file)
#
# Commentary:
#   List packages which own modified files.

version="006"

import sys
import re
from subprocess import Popen, PIPE
from optparse import OptionParser

from portage import settings
from gentoolkit.helpers import FileOwner, get_installed_cpvs
from gentoolkit.package import Package
from gentoolkit.equery.check import VerifyContents

if __name__ == "__main__":
    parser = OptionParser(
        usage="%prog [-q] [-p] [path ...]",
        version="%prog-"+version,
        description="list packages that have modified files",
        epilog="For more information see echanged(1).")
    parser.add_option(
        "-q", "--quiet",
        action="store_false", dest="verbose", default=True,
        help="do not list files along with packages")
    parser.add_option(
        "-a", "--all",
        action="store_true", dest="show_all", default=False,
        help="list all modified files even if not in <path> or not config protected")
    parser.add_option(
        "-p", "--protected",
        action="store_true", default=False,
        help="only test packages which own config protected files")

    options, paths = parser.parse_args()
    all_packages = [Package(x) for x in get_installed_cpvs()]
    prune = []
    paths_regex = None
    pmask_regex = None

    if options.protected:
        if len(paths) > 0:
            parser.error("option -p and argument PATH are mutually exclusive")
        paths = settings.get("CONFIG_PROTECT", "").split()
        pmask = settings.get("CONFIG_PROTECT_MASK", "").split()
        pmask_regex = re.compile("(" + "|".join(pmask) + ")")
        for m in pmask:
            prune = prune + ["-path", m, "-prune", "-o"]

    if paths:
        find = Popen(["find"]+paths+prune+["-print"], stdout=PIPE)
        sort = Popen(["sort"], stdin=find.stdout, stdout=PIPE)
        files, stderrdata = sort.communicate()
        files = files.splitlines()
        paths_regex = re.compile("(" + "|".join(paths) + ")")
        own_packages = []

        findowner = FileOwner(early_out=True)
        for cfile in files:
            pkgs = findowner((cfile,))
            if pkgs:
                if not pkgs[0][0] in own_packages:
                    own_packages.append(pkgs[0][0])
                    
    else:
        own_packages = all_packages
    own_packages.sort()

    for pkg in own_packages:
        pkg_files = pkg.parsed_contents()
        passed, checked, errs = VerifyContents()._run_checks(pkg_files)
        changed = []
        for err in errs:
            if options.show_all or \
                    ((not paths_regex or paths_regex.match(err)) and \
                     (not pmask_regex or not pmask_regex.match(err))):
                changed.append(err.split(" ", 1))
        if changed:
            changed.sort()
            print pkg.cpv
            if options.verbose:
                for err in changed:
                    print "    %-40s %s" % tuple(err)
                print
