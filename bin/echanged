#!/usr/bin/python
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Author:  Jonas Bernoulli <jonas@bernoul.li>
# Created: 20090909
# Updated: 20090924
# Version: 003 (this file)
#
# Commentary:
#   List packages which own modified files.

version="003"

import sys
import re
from subprocess import Popen, PIPE
from optparse import OptionParser

from portage import settings
from gentoolkit.helpers2 import get_installed_cpvs
from gentoolkit.package import Package
from gentoolkit.equery.check import run_checks

from etools import get_owner

if __name__ == "__main__":
    parser = OptionParser(
        usage="%prog [-q] [-p] [path ...]",
        version="%prog-"+version,
        description="list packages that have modified files",
        epilog="For more information see echanged(1).")
    parser.add_option(
        "-q", "--quiet",
        action="store_false", dest="verbose", default=True,
        help="do not list files along with packages")
    parser.add_option(
        "-a", "--all",
        action="store_true", default=False,
        help="list all modified files even if not in PATH or not config-protected")
    parser.add_option(
        "-p", "--protected",
        action="store_true", default=False,
        help="only test packages which own config protected files")

    options, paths = parser.parse_args()
    all_packages = [Package(x) for x in get_installed_cpvs()]
    prune = []
    regex_path = None
    regex_mask = None

    if options.protected:
        if len(paths) > 0:
            parser.error("option -p and argument PATH are mutually exclusive")
        paths = settings.get("CONFIG_PROTECT", "").split()
        pmask = settings.get("CONFIG_PROTECT_MASK", "").split()
        pmask_regex = re.compile("(" + "|".join(pmask) + ")")
        for m in cmask:
            prune = prune + ["-path", m, "-prune", "-o"]

    if paths:
        find = Popen(["find"]+prune+paths, stdout=PIPE)
        sort = Popen(["sort"], stdin=find.stdout, stdout=PIPE)
        files, stderrdata = sort.communicate()
        files = files.splitlines()
        paths_regex = re.compile("(" + "|".join(paths) + ")")
        own_packages = []

        for cfile in files:
            pkg = get_owner(cfile, all_packages)
            if len(pkg) > 0:
                pkg = Package(pkg[0])
                if not pkg in own_packages:
                    own_packages.append(pkg)
                    
    else:
        own_packages = all_packages

    for pkg in own_packages:
        passed, checked, errs = run_checks(pkg.get_contents())
        changed = []
        for cfile in errs:
            if not paths_regex or paths_regex.match(cfile):
                if not pmask_regex or not pmask_regex.match(cfile):
                    changed.append(cfile)
        if changed:
            print pkg.get_cpv()
            if verbose:
                for err in changed:
                    print "    "+err
                print ""
